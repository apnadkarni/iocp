<!DOCTYPE html><html><head><meta charset="utf-8"/>
<title>iocp package reference (V1.0.9)</title>
<style>
/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var,optgroup{font-style:inherit;font-weight:inherit;}del,ins{text-decoration:none;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:baseline;}sub{vertical-align:baseline;}legend{color:#000;}input,button,textarea,select,optgroup,option{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;}input,button,textarea,select{*font-size:100%;}body{font:13px/1.231 arial,helvetica,clean,sans-serif;*font-size:small;*font:x-small;}select,input,button,textarea,button{font:99% arial,helvetica,clean,sans-serif;}table{font-size:inherit;font:100%;}pre,code,kbd,samp,tt{font-family:monospace;*font-size:108%;line-height:100%;}body{text-align:center;}#doc,#doc2,#doc3,#doc4,.yui-t1,.yui-t2,.yui-t3,.yui-t4,.yui-t5,.yui-t6,.yui-t7{margin:auto;text-align:left;width:57.69em;*width:56.25em;}#doc2{width:73.076em;*width:71.25em;}#doc3{margin:auto 10px;width:auto;}#doc4{width:74.923em;*width:73.05em;}.yui-b{position:relative;}.yui-b{_position:static;}#yui-main .yui-b{position:static;}#yui-main,.yui-g .yui-u .yui-g{width:100%;}.yui-t1 #yui-main,.yui-t2 #yui-main,.yui-t3 #yui-main{float:right;margin-left:-25em;}.yui-t4 #yui-main,.yui-t5 #yui-main,.yui-t6 #yui-main{float:left;margin-right:-25em;}.yui-t1 .yui-b{float:left;width:12.30769em;*width:12.00em;}.yui-t1 #yui-main .yui-b{margin-left:13.30769em;*margin-left:13.05em;}.yui-t2 .yui-b{float:left;width:13.8461em;*width:13.50em;}.yui-t2 #yui-main .yui-b{margin-left:14.8461em;*margin-left:14.55em;}.yui-t3 .yui-b{float:left;width:23.0769em;*width:22.50em;}.yui-t3 #yui-main .yui-b{margin-left:24.0769em;*margin-left:23.62em;}.yui-t4 .yui-b{float:right;width:13.8456em;*width:13.50em;}.yui-t4 #yui-main .yui-b{margin-right:14.8456em;*margin-right:14.55em;}.yui-t5 .yui-b{float:right;width:18.4615em;*width:18.00em;}.yui-t5 #yui-main .yui-b{margin-right:19.4615em;*margin-right:19.125em;}.yui-t6 .yui-b{float:right;width:23.0769em;*width:22.50em;}.yui-t6 #yui-main .yui-b{margin-right:24.0769em;*margin-right:23.62em;}.yui-t7 #yui-main .yui-b{display:block;margin:0 0 1em 0;}#yui-main .yui-b{float:none;width:auto;}.yui-gb .yui-u,.yui-g .yui-gb .yui-u,.yui-gb .yui-g,.yui-gb .yui-gb,.yui-gb .yui-gc,.yui-gb .yui-gd,.yui-gb .yui-ge,.yui-gb .yui-gf,.yui-gc .yui-u,.yui-gc .yui-g,.yui-gd .yui-u{float:left;}.yui-g .yui-u,.yui-g .yui-g,.yui-g .yui-gb,.yui-g .yui-gc,.yui-g .yui-gd,.yui-g .yui-ge,.yui-g .yui-gf,.yui-gc .yui-u,.yui-gd .yui-g,.yui-g .yui-gc .yui-u,.yui-ge .yui-u,.yui-ge .yui-g,.yui-gf .yui-g,.yui-gf .yui-u{float:right;}.yui-g div.first,.yui-gb div.first,.yui-gc div.first,.yui-gd div.first,.yui-ge div.first,.yui-gf div.first,.yui-g .yui-gc div.first,.yui-g .yui-ge div.first,.yui-gc div.first div.first{float:left;}.yui-g .yui-u,.yui-g .yui-g,.yui-g .yui-gb,.yui-g .yui-gc,.yui-g .yui-gd,.yui-g .yui-ge,.yui-g .yui-gf{width:49.1%;}.yui-gb .yui-u,.yui-g .yui-gb .yui-u,.yui-gb .yui-g,.yui-gb .yui-gb,.yui-gb .yui-gc,.yui-gb .yui-gd,.yui-gb .yui-ge,.yui-gb .yui-gf,.yui-gc .yui-u,.yui-gc .yui-g,.yui-gd .yui-u{width:32%;margin-left:1.99%;}.yui-gb .yui-u{*margin-left:1.9%;*width:31.9%;}.yui-gc div.first,.yui-gd .yui-u{width:66%;}.yui-gd div.first{width:32%;}.yui-ge div.first,.yui-gf .yui-u{width:74.2%;}.yui-ge .yui-u,.yui-gf div.first{width:24%;}.yui-g .yui-gb div.first,.yui-gb div.first,.yui-gc div.first,.yui-gd div.first{margin-left:0;}.yui-g .yui-g .yui-u,.yui-gb .yui-g .yui-u,.yui-gc .yui-g .yui-u,.yui-gd .yui-g .yui-u,.yui-ge .yui-g .yui-u,.yui-gf .yui-g .yui-u{width:49%;*width:48.1%;*margin-left:0;}.yui-g .yui-g .yui-u{width:48.1%;}.yui-g .yui-gb div.first,.yui-gb .yui-gb div.first{*margin-right:0;*width:32%;_width:31.7%;}.yui-g .yui-gc div.first,.yui-gd .yui-g{width:66%;}.yui-gb .yui-g div.first{*margin-right:4%;_margin-right:1.3%;}.yui-gb .yui-gc div.first,.yui-gb .yui-gd div.first{*margin-right:0;}.yui-gb .yui-gb .yui-u,.yui-gb .yui-gc .yui-u{*margin-left:1.8%;_margin-left:4%;}.yui-g .yui-gb .yui-u{_margin-left:1.0%;}.yui-gb .yui-gd .yui-u{*width:66%;_width:61.2%;}.yui-gb .yui-gd div.first{*width:31%;_width:29.5%;}.yui-g .yui-gc .yui-u,.yui-gb .yui-gc .yui-u{width:32%;_float:right;margin-right:0;_margin-left:0;}.yui-gb .yui-gc div.first{width:66%;*float:left;*margin-left:0;}.yui-gb .yui-ge .yui-u,.yui-gb .yui-gf .yui-u{margin:0;}.yui-gb .yui-gb .yui-u{_margin-left:.7%;}.yui-gb .yui-g div.first,.yui-gb .yui-gb div.first{*margin-left:0;}.yui-gc .yui-g .yui-u,.yui-gd .yui-g .yui-u{*width:48.1%;*margin-left:0;}.yui-gb .yui-gd div.first{width:32%;}.yui-g .yui-gd div.first{_width:29.9%;}.yui-ge .yui-g{width:24%;}.yui-gf .yui-g{width:74.2%;}.yui-gb .yui-ge div.yui-u,.yui-gb .yui-gf div.yui-u{float:right;}.yui-gb .yui-ge div.first,.yui-gb .yui-gf div.first{float:left;}.yui-gb .yui-ge .yui-u,.yui-gb .yui-gf div.first{*width:24%;_width:20%;}.yui-gb .yui-ge div.first,.yui-gb .yui-gf .yui-u{*width:73.5%;_width:65.5%;}.yui-ge div.first .yui-gd .yui-u{width:65%;}.yui-ge div.first .yui-gd div.first{width:32%;}#hd:after,#bd:after,#ft:after,.yui-g:after,.yui-gb:after,.yui-gc:after,.yui-gd:after,.yui-ge:after,.yui-gf:after{content:".";display:block;height:0;clear:both;visibility:hidden;}#hd,#bd,#ft,.yui-g,.yui-gb,.yui-gc,.yui-gd,.yui-ge,.yui-gf{zoom:1;}

body{margin:10px;}h1{font-size:138.5%;}h2{font-size:123.1%;}h3{font-size:108%;}h1,h2,h3{margin:1em 0;}h1,h2,h3,h4,h5,h6,strong,dt{font-weight:bold;}optgroup{font-weight:normal;}abbr,acronym{border-bottom:1px dotted #000;cursor:help;}em{font-style:italic;}del{text-decoration:line-through;}blockquote,ul,ol,dl{margin:1em;}ol,ul,dl{margin-left:2em;}ol li{list-style:decimal outside;}ul li{list-style:disc outside;}dl dd{margin-left:1em;}th,td{border:1px solid #000;padding:.5em;}th{font-weight:bold;text-align:center;}caption{margin-bottom:.5em;text-align:center;}sup{vertical-align:super;}sub{vertical-align:sub;}p,fieldset,table,pre{margin-bottom:1em;}button,input[type="checkbox"],input[type="radio"],input[type="reset"],input[type="submit"]{padding:1px;}


/* Ruff default CSS */

body {
  max-width: 70em;
  margin: 0;
}

h1,h2 {
  color: #888888;
  margin-bottom: 0.5em;
  margin-top: 0em;
}

#ft {
  text-align: left;
  border-top: 1px solid #006666;
  color: #888888;
  margin-top: 10px;
}

.banner h2 {
  color: #006666;
}

#hd.banner {
 font-family: "Times New Roman", serif;
 font-size: 200%;
 line-height: 64px;
 border-bottom: thin solid #006666;
 color: #006666;
}

p.linkline {
    text-align: right;
    font-size: smaller;
    /*    margin-top: -1em; */
    margin-bottom: 0;
}

.tinylink {
    font-size: x-small;
    font-variant: normal;
    font-family: Arial, sans-serif;
    float: right;
    padding:2px;
}

h1 .tinylink a {
    color: white;
}

#bd {
font-family: Arial, sans-serif;
font-size: 108%;
}

div.navbox {
  /* margin-top: 1em; */
    background-color: #006666;
    color: white;
    padding: 3px 4px 2px 4px;
    font-family: Arial, sans-serif;
    overflow: hidden;
}

div.navbox:hover {
    overflow: visible;
}

/* Note .navbox header css should be based on $header_levels */
.navbox h1, .navbox h2, .navbox h3, .navbox h4, .navbox h5 {
  font-size: 85%;
  margin: 0px;
  font-weight: normal;
}
.navbox h1 {
    font-weight: bold; /* Override */
}
.navbox h2 {
  padding-left: 1em;
}
.navbox h3 {
  padding-left: 2em;
}
.navbox h4 {
  padding-left: 2.5em;
  font-weight: normal;
}
.navbox h5 {
  padding-left: 3em;
  font-weight: normal;
}
.navbox hr {
  color: white;
  margin-top:0.1em;
  margin-bottom:0.1em;
}

.navbox a:link, .navbox a:visited, .navbox a:hover {
  text-decoration: none;
  color: white;
  background-color: #006666;
}

.navbox a:hover {
   font-weight: bold;
}

/* Tooltip text - see https://www.w3schools.com/css/css_tooltip.asp */
.tooltip {
    position: relative;
    /* display: inline-block; */
}

.tooltip .tooltiptext {
    width: 100%;
    font-weight: bold;
    background-color: white;
    color: #006666;
    text-align: left;
    border: 1px solid #006666;
    /* border-radius: 4px; */
    position: absolute;
    z-index: 1;
    margin-left: 4px;
    padding: 2px 3px;
    visibility: hidden;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tooltip:hover .tooltiptext {
    visibility: visible;
}

span.ns_scope {
    color: #aaaaaa;
}

span.ns_scope a:link, span.ns_scope a:visited {
  text-decoration: none;
  color: #aaaaaa;

}

li {
  margin-top: 0.5em;
}

span.ns_scope a:hover {
  text-decoration: none;
  color: #666666;
}

table {
  margin: 1em;
  margin-top: 0.5em;
  border: thin solid;
  border-collapse: collapse;
  border-color: #808080;
  padding: 4px;
}

td {
  border: thin solid;
  border-color: #808080;
  vertical-align: top;
  font-size: 93%;
  padding: 0.3em;
  padding-top: 0.1em;
}
th {
  border: thin solid;
  border-color: #808080;
  padding: 0.3em;
  padding-top: 0.1em;
  background-color: #CCCCCC;
}

dt, dd {
   font-size: 93%;
}

h1.ruff {
    background-color: #006666;
    color: #ffffff;
    padding-left: 0.2em;
    font-family: "Times New Roman", serif;
}
h2.ruff {
    font-variant: small-caps;
    color: #006666;
    font-family: "Times New Roman", serif;
}

h3.ruff, h4.ruff, h5.ruff, h6.ruff {
    color: #006666;
}
h5.ruff {
    font-style: italic;
    font-weight: normal;
}
h6.ruff {
    font-weight: normal;
}
h3.ruffclass, h3.ruffproc, h3.ruffmethod,
h4.ruffclass, h4.ruffproc, h4.ruffmethod,
h5.ruffclass, h5.ruffproc, h5.ruffmethod {
    border-bottom: thin solid #006666;
    color: #006666;
    margin-bottom: 0.2em;
}

pre {
    background-color: #eeeeee;
    margin-top: 1em;
    margin-left: 1em;
    padding: 5px;
    font-family: Consolas, "Courier New", monospace;
    width: max-content;
    font-size: smaller;
    line-height: 1.2em;
}

.ruff_dyn_src {
    display: none; /* Displayed via JS */
}

.ruff_synopsis {
    border: thin solid #cccccc;
    background: #eeeeee;
    font-size: smaller;
    font-family: Consolas, "Courier New", monospace;
    padding: 5px;
    margin: 0em 2em 1em;
}
.ruff_const, .ruff_cmd, ruff_defitem {
    font-weight: bold;
    font-family: Consolas, "Courier New", monospace;
}
.ruff_arg {
    font-style: italic;
    font-family: Consolas, "Courier New", monospace;
}

.ruff_source_link {
    font-size: smaller;
}

.ruff_index {
    font-size: small;
    color: grey;
    line-height: 1;
}

.ruff_index ul li {
    list-style-type: none;
}

.ruff_index ul li a {
    text-decoration: none;
}
</style>
<script>function toggleSource( id )
{
    /* Copied from Rails */
    var elem
    var link

    if( document.getElementById )
    {
        elem = document.getElementById( id )
        link = document.getElementById( "l_" + id )
    }
    else if ( document.all )
    {
        elem = eval( "document.all." + id )
        link = eval( "document.all.l_" + id )
    }
    else
        return false;

    if( elem.style.display == "block" )
    {
        elem.style.display = "none"
        link.innerHTML = "Show source"
    }
    else
    {
        elem.style.display = "block"
        link.innerHTML = "Hide source"
    }
}
</script></head>
<body><div id='doc3' class='yui-t2'><div id='hd' class='banner'>
<a style='text-decoration:none;' href='iocp.html'>iocp package reference (V1.0.9)</a>
</div>
<div id='bd'><div id='yui-main'><div class='yui-b'><h1 class='ruff'><a name='::iocp::bt'></a>::iocp::bt<span class='tinylink'><a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h1>
<div style='clear:both;'></div>
<p class='ruff'>The <code>iocp_bt</code> package implements Bluetooth support and is loaded as</p>
<pre class='ruff'>
package require iocp_bt
</pre>
<p class='ruff'>The commands are broken into the following namespaces:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>::iocp::bt</td><td class='ruff_defitem'>Core commands for Bluetooth communication.</td></tr>
<tr><td class='ruff_defitem'>::iocp::bt::sdr</td><td class='ruff_defitem'>Commands for handling Bluetooth service discovery records.</td></tr>
<tr><td class='ruff_defitem'>::iocp::bt::names</td><td class='ruff_defitem'>Commands for mapping Bluetooth UUIDs and names.</td></tr>
</table>
<p class='ruff'>Note the current limitations:</p>
<ul class='ruff'>
<li>Only client-side communication is implemented in this release. Server-side functionality will be added in some future release based on demand.</li>
<li>Only RFCOMM channels are supported. There is no support for L2CAP or other protocols as these are not exposed at the Win32 API level.</li>
<li>Bluetooth LE is not currently supported.</li>
</ul>
<p class='ruff'>This documentation is a reference for the package. For an introductory guide, see the <a href="https://www.magicsplat.com/blog/tags/bluetooth/" >tutorials</a>.</p>
<h2 class='ruff'><a name='::iocp::bt-Device discovery'></a>Device discovery<span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h2>
<div style='clear:both;'></div>
<p class='ruff'>Remote Bluetooth devices are discovered through <a href="iocp_iocp_bt.html#::iocp::bt::devices" title="devices" class='ruff_cmd'>devices</a> command. It is generally recommended that a new device inquiry be initiated with the <code>-inquire</code> option when using this command as otherwise newly reachable devices will not be discovered. The <a href="iocp_iocp_bt.html#::iocp::bt::device printn" title="device printn" class='ruff_cmd'>device printn</a> command will print the information related to each device in human-readable form.</p>
<p class='ruff'>Bluetooth radios on the local system can be enumerated with the <a href="iocp_iocp_bt.html#::iocp::bt::radios" title="radios" class='ruff_cmd'>radios</a> command. There is however rarely a need to do this as it is not required for a establishing a Bluetooth connection.</p>
<h2 class='ruff'><a name='::iocp::bt-Service discovery'></a>Service discovery<span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h2>
<div style='clear:both;'></div>
<p class='ruff'>A device will generally host multiple services. The <a href="iocp_iocp_bt.html#::iocp::bt::device services" title="device services" class='ruff_cmd'>device services</a> commands will retrieve information about the services advertised by the device. This information is in the form of <em>service discovery records</em>. Commands for parsing these records are contained in the <a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="sdr" class='ruff_cmd'>sdr</a> namespace.</p>
<p class='ruff'>Services and service classes are identified with UUID's. Most commands will however accept mnemonics for services defined in the standard as they are easier to remember than the UUID's. The <a href="iocp_iocp_bt_names.html#::iocp::bt::names::print" title="names::print" class='ruff_cmd'>names::print</a> command will print the list of mnemonics and the corresponding UUID's.</p>
<h2 class='ruff'><a name='::iocp::bt-Connection establishment'></a>Connection establishment<span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h2>
<div style='clear:both;'></div>
<p class='ruff'>Establishing a Bluetooth connection involves the following steps.</p>
<p class='ruff'>First, the device name has to be mapped to its physical address. Unlike the TCP sockets in Tcl, Bluetooth sockets require physical addresses to be specified as device names are ambiguous. The <a href="iocp_iocp_bt.html#::iocp::bt::device address" title="device address" class='ruff_cmd'>device address</a> command can be used to obtain the physical addresses corresponding to a name. Note that there can be multiple devices with the same name so the command returns a list of addresses, one per device. When the list contains more than one address, generally the user needs to be prompted to pick one though below we just assume there is a single address in the list.</p>
<pre class='ruff'>
set addrs [iocp::bt::device_address &quot;APN Phone&quot;]
set addr  [lindex $addrs 0]
</pre>
<p class='ruff'>Next, the port the service is listening on needs to be resolved with the <a href="iocp_iocp_bt.html#::iocp::bt::device port" title="device port" class='ruff_cmd'>device port</a> command. In the example below, <code>OBEXObjectPush</code> is the service of interest.</p>
<pre class='ruff'>
set port [iocp::bt::service_port $addr OBEXObjectPush]
</pre>
<p class='ruff'>Finally, a connection is established to the service using the <a href="iocp_iocp_bt.html#::iocp::bt::socket" title="socket" class='ruff_cmd'>socket</a> command.</p>
<pre class='ruff'>
set so [iocp::bt::socket $addr $port]
</pre>
<p class='ruff'>Other commands in the namespace provide supporting functions such as device and service discovery.</p>
<h2 class='ruff'><a name='::iocp::bt-Commands'></a>Commands<span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h2>
<div style='clear:both;'></div>
<h4 class='ruffproc'><a name='::iocp::bt::device address'>device address</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Returns a list of Bluetooth addresses for a given name.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>device address</span> <span class='ruff_arg'>name ?args?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>name</code></td><td class='ruff_defitem'>Name of device of interest.</td></tr>
<tr><td class='ruff_defitem'><code>args</code></td><td class='ruff_defitem'>Options to control device enquiry. See <a href="iocp_iocp_bt.html#::iocp::bt::devices" title="devices" class='ruff_cmd'>devices</a>.</td></tr>
</table>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a list of Bluetooth addresses for a given name.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_1' href="javascript:toggleSource('1')">Show source</a></p>
<div id='1' class='ruff_dyn_src'><pre>proc ::iocp::bt::device::address {name args} {

    # Returns a list of Bluetooth addresses for a given name.
    # name - name of device of interest
    # args - Options to control device enquiry. See [devices].

    set addresses [lmap device [devices] {
        if {[string compare -nocase $name [dict get $device Name]]} {
            continue
        }
        dict get $device Address
    }]
    # Also resolve local system radios
    foreach radio [radios 1] {
        if {[string equal -nocase $name [dict get $radio Name]]} {
            lappend addresses [dict get $radio Address]
        }
    }
    return $addresses
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::device port'>device port</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Resolve the port for a Bluetooth service running over RFCOMM.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>device port</span> <span class='ruff_arg'>device service_class</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>device</code></td><td class='ruff_defitem'>Bluetooth address or name of a device. If specified as a name, it must resolve to a single address.</td></tr>
<tr><td class='ruff_defitem'><code>service_class</code></td><td class='ruff_defitem'>UUID or name of service class of interest. Note the service <strong>name</strong> cannot be used for lookup.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>In case multiple services of the same service class are available on the device, the port for the first one discovered is returned.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns the port number for the service or raises an error if it cannot be resolved.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_2' href="javascript:toggleSource('2')">Show source</a></p>
<div id='2' class='ruff_dyn_src'><pre>proc ::iocp::bt::device::port {device service_class} {

    # Resolve the port for a Bluetooth service running over RFCOMM.
    #  device - Bluetooth address or name of a device. If specified as a name,
    #           it must resolve to a single address.
    #  service_class - UUID or name of service class of interest. Note the
    #           service **name** cannot be used for lookup.
    #
    # In case multiple services of the same service class are available on the
    # device, the port for the first one discovered is returned.
    #
    # Returns the port number for the service or raises an error if it
    # cannot be resolved.

    #TBD - maybe use device::services and loop through so we can match service_class
    #against service name as well

    set h [LookupServiceBegin  [ResolveDeviceUnique $device]  [names::service_class_uuid $service_class]]
    try {
        while {1} {
            # 0x100 -&gt; LUP_RETURN_ADDR
            set rec [LookupServiceNext $h 0x100]
            if {[dict exists $rec RemoteAddress] &amp;&amp;
                [dict get $rec RemoteAddress AddressFamily] == 32} {
                # 32 -&gt; AF_BTH (Bluetooth)
                # Further we are looking for RFCOMM (protocol 3)
                if {[dict exists $rec Protocol] &amp;&amp;
                    [dict get $rec Protocol] == 3} {
                    return [dict get $rec RemoteAddress Port]
                }
            }
        }
    } finally {
        LookupServiceEnd $h
    }
    error &quot;Could not resolve service \&quot;$service_class\&quot; to a port on device \&quot;$device\&quot;.&quot;
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::device print'>device print</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Prints device information in human-readable form to stdout.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>device print</span> <span class='ruff_arg'>devinfo</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>devinfo</code></td><td class='ruff_defitem'>A device information record as returned by the <a href="iocp_iocp_bt.html#::iocp::bt::devices" title="devices" class='ruff_cmd'>devices</a> command.</td></tr>
</table>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_3' href="javascript:toggleSource('3')">Show source</a></p>
<div id='3' class='ruff_dyn_src'><pre>proc ::iocp::bt::device::print {devinfo} {

    # Prints device information in human-readable form to stdout.
    #  devinfo - A device information record as returned by
    #            the [devices] command.
    dict with devinfo {
        puts &quot;Device $Name&quot;
        puts &quot;Address: $Address&quot;
        puts &quot;Class: $Class ($MajorClassName:$MinorClassName)&quot;
        puts &quot;Device categories: ([join $DeviceClasses {, }])&quot;
        puts &quot;Authenticated: $Authenticated&quot;
        puts &quot;Remembered: $Remembered&quot;
        puts &quot;Connected: $Connected&quot;
        puts &quot;Last seen: $LastSeen&quot;
        puts &quot;Last used: $LastUsed&quot;
    }
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::device printn'>device printn</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Prints device information in human-readable form to stdout.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>device printn</span> <span class='ruff_arg'>dinfolist ?detailed?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>dinfolist</code></td><td class='ruff_defitem'>A list of device information records as returned by the <a href="iocp_iocp_bt.html#::iocp::bt::devices" title="devices" class='ruff_cmd'>devices</a> command.</td></tr>
<tr><td class='ruff_defitem'><code>detailed</code></td><td class='ruff_defitem'>If a true value, detailed information about the device is printed. If false (default), only the address and name are printed in compact form. Optional, default <code>false</code>.</td></tr>
</table>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_4' href="javascript:toggleSource('4')">Show source</a></p>
<div id='4' class='ruff_dyn_src'><pre>proc ::iocp::bt::device::printn {dinfolist {detailed false}} {

    # Prints device information in human-readable form to stdout.
    #  dinfolist - A list of device information records as returned by
    #            the [devices] command.
    #  detailed - If a true value, detailed information about the device
    #             is printed. If false (default), only the address and
    #             name are printed in compact form.
    set sep &quot;&quot;
    foreach dinfo $dinfolist {
        if {$detailed} {
            puts $sep
            set sep &quot;----------------------------------------------&quot;
            print $dinfo
        } else {
            dict with dinfo {
                puts &quot;$Address $Name&quot;
            }
        }
    }
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::device remove'>device remove</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Removes cached authentication information for a device from the system cache.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>device remove</span> <span class='ruff_arg'>device</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>device</code></td><td class='ruff_defitem'>Bluetooth address or name of a device. if specified as a name, it must resolve to a single address.</td></tr>
</table>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_5' href="javascript:toggleSource('5')">Show source</a></p>
<div id='5' class='ruff_dyn_src'><pre>proc ::iocp::bt::device::remove {device} {

    # Removes cached authentication information for a device from the system cache.
    #  device - bluetooth address or name of a device. if specified as a name,
    #           it must resolve to a single address.

    RemoveDevice [ResolveDeviceUnique $device]
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::device service_references'>device service_references</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Retrieve service discovery records that refer to a specified service.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>device service_references</span> <span class='ruff_arg'>device service</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>device</code></td><td class='ruff_defitem'>Bluetooth address or name of a device. If specified as a name, it must resolve to a single address.</td></tr>
<tr><td class='ruff_defitem'><code>service</code></td><td class='ruff_defitem'>The UUID of a service or service class or its mnemonic.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>The command will return all service discovery records that contain an attribute referring to the specified service. The returned service discovery records should be treated as opaque and accessed through the service record decoding commands.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a list of service discovery records.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_6' href="javascript:toggleSource('6')">Show source</a></p>
<div id='6' class='ruff_dyn_src'><pre>proc ::iocp::bt::device::service_references {device service} {

    # Retrieve service discovery records that refer to a specified service.
    #  device - Bluetooth address or name of a device. If specified as a name,
    #           it must resolve to a single address.
    #  service - the UUID of a service or service class or its mnemonic.
    # The command will return all service discovery records that contain
    # an attribute referring to the specified service.
    # The returned service discovery records should be treated as
    # opaque and accessed through the service record decoding commands.
    #
    # Returns a list of service discovery records.

    set h [LookupServiceBegin  [ResolveDeviceUnique $device]  [names::to_uuid $service]]
    set recs {}
    try {
        while {1} {
            # 0x0200 -&gt; LUP_RETURN_BLOB. Returns {Blob BINDATA}
            lappend recs [lindex [LookupServiceNext $h 0x200] 1]
        }
    } finally {
        LookupServiceEnd $h
    }
    return $recs
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::device services'>device services</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Retrieve the service discovery records for top level services advertised by a device.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>device services</span> <span class='ruff_arg'>device</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>device</code></td><td class='ruff_defitem'>Bluetooth address or name of a device. If specified as a name, it must resolve to a single address.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>The command will return all service discovery records that reference the <code>PublicBrowseRoot</code> service class. This is not necessarily all the services on the device, only those the device advertises as the top-level services.</p>
<p class='ruff'>The returned service discovery records should be treated as opaque and accessed through the service record decoding commands.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a list of service dscovery records.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_7' href="javascript:toggleSource('7')">Show source</a></p>
<div id='7' class='ruff_dyn_src'><pre>proc ::iocp::bt::device::services {device} {

    # Retrieve the service discovery records for top level services
    # advertised by a device.
    #  device - Bluetooth address or name of a device. If specified as a name,
    #           it must resolve to a single address.
    #
    # The command will return all service discovery records that reference
    # the `PublicBrowseRoot` service class. This is not necessarily all the
    # services on the device, only those the device advertises as the
    # top-level services.
    #
    # The returned service discovery records should be treated as
    # opaque and accessed through the service record decoding commands.
    #
    # Returns a list of service dscovery records.

    # TBD - add a browse group parameter
    # TBD - perhaps check that the sdr acually refernces browse group in
    # the appropriate attribute
    return [service_references $device 00001002-0000-1000-8000-00805f9b34fb]
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::devices'>devices</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Discover Bluetooth devices.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>devices</span> <span class='ruff_arg'>?args?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>args</code></td><td class='ruff_defitem'>Optional arguments.</td></tr>
<tr><td class='ruff_defitem'><code>-authenticated</code></td><td class='ruff_defitem'>Filter for authenticated devices.</td></tr>
<tr><td class='ruff_defitem'><code>-connected</code></td><td class='ruff_defitem'>Filter for connected devices.</td></tr>
<tr><td class='ruff_defitem'><code>-inquire</code></td><td class='ruff_defitem'>Issue a new inquiry. Without this option, devices that are not already known to the system will not be discovered.</td></tr>
<tr><td class='ruff_defitem'><code>-remembered</code></td><td class='ruff_defitem'>Filter for remembered devices.</td></tr>
<tr><td class='ruff_defitem'><code>-timeout MS</code></td><td class='ruff_defitem'>Timeout for the inquiry in milliseconds. Defaults to 10240ms. Ignored if <code>-inquire</code> is not specified.</td></tr>
<tr><td class='ruff_defitem'><code>-unknown</code></td><td class='ruff_defitem'>Filter for unknown devices.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>Each device information element is returned as a dictionary with the following keys:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>Authenticated</td><td class='ruff_defitem'>Boolean value indicating whether the device has been authenticated.</td></tr>
<tr><td class='ruff_defitem'>Address</td><td class='ruff_defitem'>Bluetooth address of the devicec.</td></tr>
<tr><td class='ruff_defitem'>Class</td><td class='ruff_defitem'>Device class as a numeric value.</td></tr>
<tr><td class='ruff_defitem'>Connected</td><td class='ruff_defitem'>Boolean value indicating whether the device is connected.</td></tr>
<tr><td class='ruff_defitem'>DeviceClasses</td><td class='ruff_defitem'>Human readable list of general device class categories.</td></tr>
<tr><td class='ruff_defitem'>LastSeen</td><td class='ruff_defitem'>Time when device was last seen. The format is a list of year, month, day, hour, minutes, seconds and milliseconds.</td></tr>
<tr><td class='ruff_defitem'>LastUsed</td><td class='ruff_defitem'>Time when device was last used. The format is a list of year, month, day, hour, minutes, seconds and milliseconds.</td></tr>
<tr><td class='ruff_defitem'>MajorClassName</td><td class='ruff_defitem'>Human readable major device class name.</td></tr>
<tr><td class='ruff_defitem'>MinorClassName</td><td class='ruff_defitem'>Human readable minor device class name.</td></tr>
<tr><td class='ruff_defitem'>Name</td><td class='ruff_defitem'>Human readable name of the device.</td></tr>
<tr><td class='ruff_defitem'>Remembered</td><td class='ruff_defitem'>Boolean value indicating whether the device is connected.</td></tr>
</table>
<p class='ruff'>The filtering options may be specified to limit the devices returned. If none are specified, all devices are returned.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a list of device information dictionaries.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_8' href="javascript:toggleSource('8')">Show source</a></p>
<div id='8' class='ruff_dyn_src'><pre>proc ::iocp::bt::devices {args} {

    # Discover Bluetooth devices.
    # -authenticated - filter for authenticated devices
    # -connected     - filter for connected devices
    # -inquire       - issue a new inquiry. Without this option, devices that are
    #                  not already known to the system will not be discovered.
    # -remembered    - filter for remembered devices
    # -timeout MS    - timeout for the inquiry in milliseconds. Defaults to 10240ms.
    #                  Ignored if `-inquire` is not specified.
    # -unknown       - filter for unknown devices
    #
    # Each device information element is returned as a dictionary with
    # the following keys:
    # Authenticated - Boolean value indicating whether the device has
    #                 been authenticated
    # Address - Bluetooth address of the devicec
    # Class - Device class as a numeric value
    # Connected - Boolean value indicating whether the device is connected
    # DeviceClasses - Human readable list of general device class categories
    # LastSeen - Time when device was last seen. The format is a list of
    #            year, month, day, hour, minutes, seconds and milliseconds.
    # LastUsed - Time when device was last used. The format is a list of
    #            year, month, day, hour, minutes, seconds and milliseconds.
    # MajorClassName - Human readable major device class name.
    # MinorClassName - Human readable minor device class name.
    # Name - Human readable name of the device
    # Remembered - Boolean value indicating whether the device is connected
    #
    # The filtering options may be specified to limit the devices
    # returned. If none are specified, all devices are returned.
    #
    # Returns a list of device information dictionaries.

    set pair [FindFirstDevice {*}$args]
    if {[llength $pair] == 0} {
        # No devices found
        return {}
    }
    lassign $pair finder device
    set device [dict merge $device [DeviceClass [dict get $device Class]]]
    set devices [list $device]
    try {
        while {1} {
            set device [FindNextDevice $finder]
            set device [dict merge $device [DeviceClass [dict get $device Class]]]
            lappend devices $device
        }
    } finally {
        FindFirstDeviceClose $finder
    }
    return $devices
}</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::radio configure'>radio configure</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Gets or modifies a radio configuration.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>radio configure</span> <span class='ruff_arg'>radio ?args?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>radio</code></td><td class='ruff_defitem'>The address or name associated with a radio on the system.</td></tr>
<tr><td class='ruff_defitem'><code>args</code></td><td class='ruff_defitem'>See below.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>If no arguments are given to the command, it returns the current values of all options in the form of a dictionary.</p>
<p class='ruff'>If exactly one argument is given, it must be the name of an option and the command returns the value of the option.</p>
<p class='ruff'>Otherwise, the arguments must be a list of option name and values. The radio's options are set accordingly. The command returns an empty string for this case. Note that in case of raised exceptions the state of the radio options is indeterminate.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns an option value, a dictionary of options and values, or an empty string.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_9' href="javascript:toggleSource('9')">Show source</a></p>
<div id='9' class='ruff_dyn_src'><pre>proc ::iocp::bt::radio::configure {radio args} {

    # Gets or modifies a radio configuration.
    #  radio - The address or name associated with a radio on the system.
    #  args - See below.
    #
    # Returns an option value, a dictionary of options and values, or an empty
    # string.
    #
    # If no arguments are given to the command, it returns the current
    # values of all options in the form of a dictionary.
    #
    # If exactly one argument is given, it must be the name of an option
    # and the command returns the value of the option.
    #
    # Otherwise, the arguments must be a list of option name and
    # values. The radio's options are set accordingly. The command returns
    # an empty string for this case. Note that in case of raised exceptions
    # the state of the radio options is indeterminate.

    set hradio [Open $radio]
    try {
        if {[llength $args] == 0} {
            return [list  -discoverable [IsDiscoverable $hradio]  -connectable  [IsConnectable $hradio]]
        } elseif {[llength $args] == 1} {
            return [switch -exact -- [lindex $args 0] {
                -discoverable {IsDiscoverable $hradio}
                -connectable  {IsConnectable $hradio}
                default { error &quot;Unknown option \&quot;[lindex $args 0]\&quot;.&quot;}
            }]
        } else {
            set unchanged {}
            foreach {opt val} {
                switch -exact -- $opt {
                    -discoverable {
                        set changed [EnableDiscovery $val]
                    }
                    -connectable  {
                        set changed [EnableIncoming $val]
                    }
                    default { error &quot;Unknown option \&quot;$opt\&quot;.&quot;}
                }
                if {! $changed} {
                    lappend unchanged $opt
                }
            }
            if {[llength $unchanged]} {
                error &quot;Options [join $unchanged {, }] could not be modified.&quot;
            }
        }
    } finally {
        Close $hradio
    }
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::radio devices'>radio devices</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Discover devices accessible through the specified radio.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>radio devices</span> <span class='ruff_arg'>radio ?args?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>radio</code></td><td class='ruff_defitem'>Name or address of Bluetooth radio.</td></tr>
<tr><td class='ruff_defitem'><code>args</code></td><td class='ruff_defitem'>Passed on to <a href="iocp_iocp_bt.html#::iocp::bt::devices" title="devices" class='ruff_cmd'>devices</a></td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>This command has the same functionality as the <a href="iocp_iocp_bt.html#::iocp::bt::devices" title="devices" class='ruff_cmd'>devices</a> command except that it restricts discovery only to those devices accessible through the specified radio.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a list of device information dictionaries. See <a href="iocp_iocp_bt.html#::iocp::bt::devices" title="devices" class='ruff_cmd'>devices</a> for the dictionary format.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_10' href="javascript:toggleSource('10')">Show source</a></p>
<div id='10' class='ruff_dyn_src'><pre>proc ::iocp::bt::radio::devices {radio args} {

    # Discover devices accessible through the specified radio.
    #  radio - Name or address of Bluetooth radio
    #  args  - Passed on to [::iocp::bt::devices]
    # This command has the same functionality as the [::iocp::bt::devices]
    # command except that it restricts discovery only to those devices
    # accessible through the specified radio.
    #
    # Returns a list of device information dictionaries. See
    # [::iocp::bt::devices] for the dictionary format.

    set hradio [Open $radio]
    try {
        return [::iocp::bt::devices {*}$args -hradio $hradio]
    } finally {
        Close $hradio
    }
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::radio info'>radio info</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Get detailed information about a radio on the system</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>radio info</span> <span class='ruff_arg'>?radio?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>radio</code></td><td class='ruff_defitem'>The address or name associated with a radio on the system. If unspecified or the empty string, information about the first radio found is returned. Optional, default <code>&quot;&quot;</code>.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>The returned dictionary has the following keys:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>Address</td><td class='ruff_defitem'>The Bluetooth address of the radio.</td></tr>
<tr><td class='ruff_defitem'>Name</td><td class='ruff_defitem'>Name assigned to the local system as advertised by the radio.</td></tr>
<tr><td class='ruff_defitem'>Class</td><td class='ruff_defitem'>Device class as a numeric value.</td></tr>
<tr><td class='ruff_defitem'>DeviceClasses</td><td class='ruff_defitem'>Human readable list of general device class categories.</td></tr>
<tr><td class='ruff_defitem'>Subversion</td><td class='ruff_defitem'>Integer value whose interpretation is manufacturer-specific.</td></tr>
<tr><td class='ruff_defitem'>Manufacturer</td><td class='ruff_defitem'>Integer identifier assigned to the manufacturer.</td></tr>
<tr><td class='ruff_defitem'>MajorClassName</td><td class='ruff_defitem'>Human readable major device class name.</td></tr>
<tr><td class='ruff_defitem'>MinorClassName</td><td class='ruff_defitem'>Human readable minor device class name.</td></tr>
</table>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a dictionary containing information about the radio.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_11' href="javascript:toggleSource('11')">Show source</a></p>
<div id='11' class='ruff_dyn_src'><pre>proc ::iocp::bt::radio::info {{radio {}}} {

    # Get detailed information about a radio on the system
    #  radio - The address or name associated with a radio on the system.
    #          If unspecified or the empty string, information about
    #          the first radio found is returned.
    #
    # The returned dictionary has the following keys:
    #
    # Address - The Bluetooth address of the radio.
    # Name - Name assigned to the local system as advertised by the radio.
    # Class - Device class as a numeric value.
    # DeviceClasses - Human readable list of general device class categories
    # Subversion - Integer value whose interpretation is manufacturer-specific.
    # Manufacturer - Integer identifier assigned to the manufacturer.
    # MajorClassName - Human readable major device class name.
    # MinorClassName - Human readable minor device class name.
    #
    # Returns a dictionary containing information about the radio.

    set hradio [Open $radio]
    try {
        set radio [GetRadioInfo $hradio]
        set radio [dict merge $radio [DeviceClass [dict get $radio Class]]]
    } finally {
        Close $hradio
    }
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::radios'>radios</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Enumerate Bluetooth radios on the local system.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>radios</span> <span class='ruff_arg'>?detailed?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>detailed</code></td><td class='ruff_defitem'>If true, detailed information about each radio is returned. If false (default), only the radio addresses are returned. Optional, default <code>false</code>.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>When <code>$detailed</code> is passed as a boolean false value, a list of radio addresses is returned.</p>
<p class='ruff'>When <code>$detailed</code> is passed as a boolean true value, each element of the returned list contains the following keys:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>Address</td><td class='ruff_defitem'>The Bluetooth address of the radio.</td></tr>
<tr><td class='ruff_defitem'>Name</td><td class='ruff_defitem'>Name assigned to the local system as advertised by the radio.</td></tr>
<tr><td class='ruff_defitem'>Class</td><td class='ruff_defitem'>Device class as a numeric value.</td></tr>
<tr><td class='ruff_defitem'>DeviceClasses</td><td class='ruff_defitem'>Human readable list of general device class categories.</td></tr>
<tr><td class='ruff_defitem'>Subversion</td><td class='ruff_defitem'>Integer value whose interpretation is manufacturer-specific.</td></tr>
<tr><td class='ruff_defitem'>Manufacturer</td><td class='ruff_defitem'>Integer identifier assigned to the manufacturer.</td></tr>
<tr><td class='ruff_defitem'>MajorClassName</td><td class='ruff_defitem'>Human readable major device class name.</td></tr>
<tr><td class='ruff_defitem'>MinorClassName</td><td class='ruff_defitem'>Human readable minor device class name.</td></tr>
</table>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a list of radio addresses or radio information elements.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_12' href="javascript:toggleSource('12')">Show source</a></p>
<div id='12' class='ruff_dyn_src'><pre>proc ::iocp::bt::radios {{detailed false}} {

    # Enumerate Bluetooth radios on the local system.
    #  detailed - If true, detailed information about each radio is returned.
    #             If false (default), only the radio addresses are returned.
    #
    # When $detailed is passed as a boolean false value, a list of radio
    # addresses is returned.
    #
    # When $detailed is passed as a boolean true value,
    # each element of the returned list contains the following keys:
    # Address - The Bluetooth address of the radio.
    # Name - Name assigned to the local system as advertised by the radio.
    # Class - Device class as a numeric value.
    # DeviceClasses - Human readable list of general device class categories
    # Subversion - Integer value whose interpretation is manufacturer-specific.
    # Manufacturer - Integer identifier assigned to the manufacturer.
    # MajorClassName - Human readable major device class name.
    # MinorClassName - Human readable minor device class name.
    #
    # Returns a list of radio addresses or radio information elements.

    set pair [FindFirstRadio]
    if {[llength $pair] == 0} {
        return {}
    }
    lassign $pair finder hradio
    set radios {}
    try {
        while {1} {
            set radio [GetRadioInfo $hradio]
            if {$detailed} {
                lappend radios [dict merge $radio [DeviceClass [dict get $radio Class]]]
            } else {
                lappend radios [dict get $radio Address]
            }
            CloseHandle $hradio
            set hradio [FindNextRadio $finder]
        }
    } finally {
        FindFirstRadioClose $finder
    }
    return $radios
}</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::socket'>socket</a><span class='ns_scope'> [<a href="iocp_iocp_bt.html#::iocp::bt" title="::iocp::bt" class='ruff_cmd'>::iocp::bt</a>]</span><span class='tinylink'><a href='iocp_iocp_bt.html#::iocp::bt'>bt</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Returns a client Bluetooth RFCOMM channel.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>socket</span> <span class='ruff_arg'>?args?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>args</code></td><td class='ruff_defitem'>See below.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>The command takes the form</p>
<pre class='ruff'>
socket ?-async? device port
</pre>
<p class='ruff'>where <code>device</code> is the Bluetooth hardware address of the remote device and <code>port</code> is the RFCOMM port (channel). The <code>-async</code> option has the same effect as in the Tcl <a href="http://www.tcl-lang.org/man/tcl8.6/TclCmd/socket.htm" >socket</a> command. It returns immediately without waiting for the connection to complete.</p>
<p class='ruff'>Once the connection is established, Bluetooth channel operation is identical to that of Tcl sockets except that half closes are not supported.</p>
<p class='ruff'>The returned channel must be closed with the Tcl <code>close</code> or <code>chan close</code> command.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a client Bluetooth RFCOMM channel.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_13' href="javascript:toggleSource('13')">Show source</a></p>
<div id='13' class='ruff_dyn_src'><pre>proc ::iocp::bt::socket {args} {

    # Returns a client Bluetooth RFCOMM channel.
    #   args - see below.
    # The command takes the form
    #
    #     socket ?-async? device port
    #
    # where `device` is the Bluetooth hardware address of the
    # remote device and `port` is the RFCOMM port (channel).
    # The `-async` option has the same effect as in the Tcl
    # [socket](http://www.tcl-lang.org/man/tcl8.6/TclCmd/socket.htm)
    # command. It returns immediately without waiting for the
    # connection to complete.
    #
    # Once the connection is established, Bluetooth channel operation
    # is identical to that of Tcl sockets except that half closes
    # are not supported.
    #
    # The returned channel must be closed with the Tcl `close`
    # or `chan close` command.
}</pre></div>
</div></div></div><div class='yui-b navbox' style='position: fixed;'><h1><a style='padding-top:2px;' href='iocp.html'>Start page</a></h1>
<h1><a href='iocp_docindex.html' accesskey='i'>Index</a></h1>
<hr>
<h1><a style='color: #006666;background-color: white; margin-left:-4px; padding-left:3px;padding-right:2px;' href='iocp_iocp_bt.html'>iocp::bt</a></h1>
<h1><a href='iocp_iocp_bt_names.html'>iocp::bt::names</a></h1>
<h1><a href='iocp_iocp_bt_sdr.html'>iocp::bt::sdr</a></h1>
<h1><a href='iocp_iocp_inet.html'>iocp::inet</a></h1>
<hr><h1><a href='#::iocp::bt'>iocp::bt</a></h1><h2><a href='#::iocp::bt-Device discovery'>Device discovery</a></h2><h2><a href='#::iocp::bt-Service discovery'>Service discovery</a></h2><h2><a href='#::iocp::bt-Connection establishment'>Connection establishment</a></h2><h2><a href='#::iocp::bt-Commands'>Commands</a></h2><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::device address'>device address</a><span class='tooltiptext'>Returns a list of Bluetooth addresses for a given name.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::device port'>device port</a><span class='tooltiptext'>Resolve the port for a Bluetooth service running over RFCOMM.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::device print'>device print</a><span class='tooltiptext'>Prints device information in human-readable form to stdout.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::device printn'>device printn</a><span class='tooltiptext'>Prints device information in human-readable form to stdout.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::device remove'>device remove</a><span class='tooltiptext'>Removes cached authentication information for a device from the system cache.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::device service_references'>device service_references</a><span class='tooltiptext'>Retrieve service discovery records that refer to a specified service.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::device services'>device services</a><span class='tooltiptext'>Retrieve the service discovery records for top level services advertised by a device.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::devices'>devices</a><span class='tooltiptext'>Discover Bluetooth devices.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::radio configure'>radio configure</a><span class='tooltiptext'>Gets or modifies a radio configuration.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::radio devices'>radio devices</a><span class='tooltiptext'>Discover devices accessible through the specified radio.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::radio info'>radio info</a><span class='tooltiptext'>Get detailed information about a radio on the system
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::radios'>radios</a><span class='tooltiptext'>Enumerate Bluetooth radios on the local system.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt.html#::iocp::bt::socket'>socket</a><span class='tooltiptext'>Returns a client Bluetooth RFCOMM channel.
</span></h4></div></div><div id='ft'><div style='float: right;'>Document generated by <a href='https://ruff.magicsplat.com'>Ruff!</a></div></div>
</div></body></html>
