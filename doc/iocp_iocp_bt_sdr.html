<!DOCTYPE html><html><head><meta charset="utf-8"/>
<title>iocp package reference (V1.0.9)</title>
<style>
/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var,optgroup{font-style:inherit;font-weight:inherit;}del,ins{text-decoration:none;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:baseline;}sub{vertical-align:baseline;}legend{color:#000;}input,button,textarea,select,optgroup,option{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;}input,button,textarea,select{*font-size:100%;}body{font:13px/1.231 arial,helvetica,clean,sans-serif;*font-size:small;*font:x-small;}select,input,button,textarea,button{font:99% arial,helvetica,clean,sans-serif;}table{font-size:inherit;font:100%;}pre,code,kbd,samp,tt{font-family:monospace;*font-size:108%;line-height:100%;}body{text-align:center;}#doc,#doc2,#doc3,#doc4,.yui-t1,.yui-t2,.yui-t3,.yui-t4,.yui-t5,.yui-t6,.yui-t7{margin:auto;text-align:left;width:57.69em;*width:56.25em;}#doc2{width:73.076em;*width:71.25em;}#doc3{margin:auto 10px;width:auto;}#doc4{width:74.923em;*width:73.05em;}.yui-b{position:relative;}.yui-b{_position:static;}#yui-main .yui-b{position:static;}#yui-main,.yui-g .yui-u .yui-g{width:100%;}.yui-t1 #yui-main,.yui-t2 #yui-main,.yui-t3 #yui-main{float:right;margin-left:-25em;}.yui-t4 #yui-main,.yui-t5 #yui-main,.yui-t6 #yui-main{float:left;margin-right:-25em;}.yui-t1 .yui-b{float:left;width:12.30769em;*width:12.00em;}.yui-t1 #yui-main .yui-b{margin-left:13.30769em;*margin-left:13.05em;}.yui-t2 .yui-b{float:left;width:13.8461em;*width:13.50em;}.yui-t2 #yui-main .yui-b{margin-left:14.8461em;*margin-left:14.55em;}.yui-t3 .yui-b{float:left;width:23.0769em;*width:22.50em;}.yui-t3 #yui-main .yui-b{margin-left:24.0769em;*margin-left:23.62em;}.yui-t4 .yui-b{float:right;width:13.8456em;*width:13.50em;}.yui-t4 #yui-main .yui-b{margin-right:14.8456em;*margin-right:14.55em;}.yui-t5 .yui-b{float:right;width:18.4615em;*width:18.00em;}.yui-t5 #yui-main .yui-b{margin-right:19.4615em;*margin-right:19.125em;}.yui-t6 .yui-b{float:right;width:23.0769em;*width:22.50em;}.yui-t6 #yui-main .yui-b{margin-right:24.0769em;*margin-right:23.62em;}.yui-t7 #yui-main .yui-b{display:block;margin:0 0 1em 0;}#yui-main .yui-b{float:none;width:auto;}.yui-gb .yui-u,.yui-g .yui-gb .yui-u,.yui-gb .yui-g,.yui-gb .yui-gb,.yui-gb .yui-gc,.yui-gb .yui-gd,.yui-gb .yui-ge,.yui-gb .yui-gf,.yui-gc .yui-u,.yui-gc .yui-g,.yui-gd .yui-u{float:left;}.yui-g .yui-u,.yui-g .yui-g,.yui-g .yui-gb,.yui-g .yui-gc,.yui-g .yui-gd,.yui-g .yui-ge,.yui-g .yui-gf,.yui-gc .yui-u,.yui-gd .yui-g,.yui-g .yui-gc .yui-u,.yui-ge .yui-u,.yui-ge .yui-g,.yui-gf .yui-g,.yui-gf .yui-u{float:right;}.yui-g div.first,.yui-gb div.first,.yui-gc div.first,.yui-gd div.first,.yui-ge div.first,.yui-gf div.first,.yui-g .yui-gc div.first,.yui-g .yui-ge div.first,.yui-gc div.first div.first{float:left;}.yui-g .yui-u,.yui-g .yui-g,.yui-g .yui-gb,.yui-g .yui-gc,.yui-g .yui-gd,.yui-g .yui-ge,.yui-g .yui-gf{width:49.1%;}.yui-gb .yui-u,.yui-g .yui-gb .yui-u,.yui-gb .yui-g,.yui-gb .yui-gb,.yui-gb .yui-gc,.yui-gb .yui-gd,.yui-gb .yui-ge,.yui-gb .yui-gf,.yui-gc .yui-u,.yui-gc .yui-g,.yui-gd .yui-u{width:32%;margin-left:1.99%;}.yui-gb .yui-u{*margin-left:1.9%;*width:31.9%;}.yui-gc div.first,.yui-gd .yui-u{width:66%;}.yui-gd div.first{width:32%;}.yui-ge div.first,.yui-gf .yui-u{width:74.2%;}.yui-ge .yui-u,.yui-gf div.first{width:24%;}.yui-g .yui-gb div.first,.yui-gb div.first,.yui-gc div.first,.yui-gd div.first{margin-left:0;}.yui-g .yui-g .yui-u,.yui-gb .yui-g .yui-u,.yui-gc .yui-g .yui-u,.yui-gd .yui-g .yui-u,.yui-ge .yui-g .yui-u,.yui-gf .yui-g .yui-u{width:49%;*width:48.1%;*margin-left:0;}.yui-g .yui-g .yui-u{width:48.1%;}.yui-g .yui-gb div.first,.yui-gb .yui-gb div.first{*margin-right:0;*width:32%;_width:31.7%;}.yui-g .yui-gc div.first,.yui-gd .yui-g{width:66%;}.yui-gb .yui-g div.first{*margin-right:4%;_margin-right:1.3%;}.yui-gb .yui-gc div.first,.yui-gb .yui-gd div.first{*margin-right:0;}.yui-gb .yui-gb .yui-u,.yui-gb .yui-gc .yui-u{*margin-left:1.8%;_margin-left:4%;}.yui-g .yui-gb .yui-u{_margin-left:1.0%;}.yui-gb .yui-gd .yui-u{*width:66%;_width:61.2%;}.yui-gb .yui-gd div.first{*width:31%;_width:29.5%;}.yui-g .yui-gc .yui-u,.yui-gb .yui-gc .yui-u{width:32%;_float:right;margin-right:0;_margin-left:0;}.yui-gb .yui-gc div.first{width:66%;*float:left;*margin-left:0;}.yui-gb .yui-ge .yui-u,.yui-gb .yui-gf .yui-u{margin:0;}.yui-gb .yui-gb .yui-u{_margin-left:.7%;}.yui-gb .yui-g div.first,.yui-gb .yui-gb div.first{*margin-left:0;}.yui-gc .yui-g .yui-u,.yui-gd .yui-g .yui-u{*width:48.1%;*margin-left:0;}.yui-gb .yui-gd div.first{width:32%;}.yui-g .yui-gd div.first{_width:29.9%;}.yui-ge .yui-g{width:24%;}.yui-gf .yui-g{width:74.2%;}.yui-gb .yui-ge div.yui-u,.yui-gb .yui-gf div.yui-u{float:right;}.yui-gb .yui-ge div.first,.yui-gb .yui-gf div.first{float:left;}.yui-gb .yui-ge .yui-u,.yui-gb .yui-gf div.first{*width:24%;_width:20%;}.yui-gb .yui-ge div.first,.yui-gb .yui-gf .yui-u{*width:73.5%;_width:65.5%;}.yui-ge div.first .yui-gd .yui-u{width:65%;}.yui-ge div.first .yui-gd div.first{width:32%;}#hd:after,#bd:after,#ft:after,.yui-g:after,.yui-gb:after,.yui-gc:after,.yui-gd:after,.yui-ge:after,.yui-gf:after{content:".";display:block;height:0;clear:both;visibility:hidden;}#hd,#bd,#ft,.yui-g,.yui-gb,.yui-gc,.yui-gd,.yui-ge,.yui-gf{zoom:1;}

body{margin:10px;}h1{font-size:138.5%;}h2{font-size:123.1%;}h3{font-size:108%;}h1,h2,h3{margin:1em 0;}h1,h2,h3,h4,h5,h6,strong,dt{font-weight:bold;}optgroup{font-weight:normal;}abbr,acronym{border-bottom:1px dotted #000;cursor:help;}em{font-style:italic;}del{text-decoration:line-through;}blockquote,ul,ol,dl{margin:1em;}ol,ul,dl{margin-left:2em;}ol li{list-style:decimal outside;}ul li{list-style:disc outside;}dl dd{margin-left:1em;}th,td{border:1px solid #000;padding:.5em;}th{font-weight:bold;text-align:center;}caption{margin-bottom:.5em;text-align:center;}sup{vertical-align:super;}sub{vertical-align:sub;}p,fieldset,table,pre{margin-bottom:1em;}button,input[type="checkbox"],input[type="radio"],input[type="reset"],input[type="submit"]{padding:1px;}


/* Ruff default CSS */

body {
  max-width: 70em;
  margin: 0;
}

h1,h2 {
  color: #888888;
  margin-bottom: 0.5em;
  margin-top: 0em;
}

#ft {
  text-align: left;
  border-top: 1px solid #006666;
  color: #888888;
  margin-top: 10px;
}

.banner h2 {
  color: #006666;
}

#hd.banner {
 font-family: "Times New Roman", serif;
 font-size: 200%;
 line-height: 64px;
 border-bottom: thin solid #006666;
 color: #006666;
}

p.linkline {
    text-align: right;
    font-size: smaller;
    /*    margin-top: -1em; */
    margin-bottom: 0;
}

.tinylink {
    font-size: x-small;
    font-variant: normal;
    font-family: Arial, sans-serif;
    float: right;
    padding:2px;
}

h1 .tinylink a {
    color: white;
}

#bd {
font-family: Arial, sans-serif;
font-size: 108%;
}

div.navbox {
  /* margin-top: 1em; */
    background-color: #006666;
    color: white;
    padding: 3px 4px 2px 4px;
    font-family: Arial, sans-serif;
    overflow: hidden;
}

div.navbox:hover {
    overflow: visible;
}

/* Note .navbox header css should be based on $header_levels */
.navbox h1, .navbox h2, .navbox h3, .navbox h4, .navbox h5 {
  font-size: 85%;
  margin: 0px;
  font-weight: normal;
}
.navbox h1 {
    font-weight: bold; /* Override */
}
.navbox h2 {
  padding-left: 1em;
}
.navbox h3 {
  padding-left: 2em;
}
.navbox h4 {
  padding-left: 2.5em;
  font-weight: normal;
}
.navbox h5 {
  padding-left: 3em;
  font-weight: normal;
}
.navbox hr {
  color: white;
  margin-top:0.1em;
  margin-bottom:0.1em;
}

.navbox a:link, .navbox a:visited, .navbox a:hover {
  text-decoration: none;
  color: white;
  background-color: #006666;
}

.navbox a:hover {
   font-weight: bold;
}

/* Tooltip text - see https://www.w3schools.com/css/css_tooltip.asp */
.tooltip {
    position: relative;
    /* display: inline-block; */
}

.tooltip .tooltiptext {
    width: 100%;
    font-weight: bold;
    background-color: white;
    color: #006666;
    text-align: left;
    border: 1px solid #006666;
    /* border-radius: 4px; */
    position: absolute;
    z-index: 1;
    margin-left: 4px;
    padding: 2px 3px;
    visibility: hidden;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tooltip:hover .tooltiptext {
    visibility: visible;
}

span.ns_scope {
    color: #aaaaaa;
}

span.ns_scope a:link, span.ns_scope a:visited {
  text-decoration: none;
  color: #aaaaaa;

}

li {
  margin-top: 0.5em;
}

span.ns_scope a:hover {
  text-decoration: none;
  color: #666666;
}

table {
  margin: 1em;
  margin-top: 0.5em;
  border: thin solid;
  border-collapse: collapse;
  border-color: #808080;
  padding: 4px;
}

td {
  border: thin solid;
  border-color: #808080;
  vertical-align: top;
  font-size: 93%;
  padding: 0.3em;
  padding-top: 0.1em;
}
th {
  border: thin solid;
  border-color: #808080;
  padding: 0.3em;
  padding-top: 0.1em;
  background-color: #CCCCCC;
}

dt, dd {
   font-size: 93%;
}

h1.ruff {
    background-color: #006666;
    color: #ffffff;
    padding-left: 0.2em;
    font-family: "Times New Roman", serif;
}
h2.ruff {
    font-variant: small-caps;
    color: #006666;
    font-family: "Times New Roman", serif;
}

h3.ruff, h4.ruff, h5.ruff, h6.ruff {
    color: #006666;
}
h5.ruff {
    font-style: italic;
    font-weight: normal;
}
h6.ruff {
    font-weight: normal;
}
h3.ruffclass, h3.ruffproc, h3.ruffmethod,
h4.ruffclass, h4.ruffproc, h4.ruffmethod,
h5.ruffclass, h5.ruffproc, h5.ruffmethod {
    border-bottom: thin solid #006666;
    color: #006666;
    margin-bottom: 0.2em;
}

pre {
    background-color: #eeeeee;
    margin-top: 1em;
    margin-left: 1em;
    padding: 5px;
    font-family: Consolas, "Courier New", monospace;
    width: max-content;
    font-size: smaller;
    line-height: 1.2em;
}

.ruff_dyn_src {
    display: none; /* Displayed via JS */
}

.ruff_synopsis {
    border: thin solid #cccccc;
    background: #eeeeee;
    font-size: smaller;
    font-family: Consolas, "Courier New", monospace;
    padding: 5px;
    margin: 0em 2em 1em;
}
.ruff_const, .ruff_cmd, ruff_defitem {
    font-weight: bold;
    font-family: Consolas, "Courier New", monospace;
}
.ruff_arg {
    font-style: italic;
    font-family: Consolas, "Courier New", monospace;
}

.ruff_source_link {
    font-size: smaller;
}

.ruff_index {
    font-size: small;
    color: grey;
    line-height: 1;
}

.ruff_index ul li {
    list-style-type: none;
}

.ruff_index ul li a {
    text-decoration: none;
}
</style>
<script>function toggleSource( id )
{
    /* Copied from Rails */
    var elem
    var link

    if( document.getElementById )
    {
        elem = document.getElementById( id )
        link = document.getElementById( "l_" + id )
    }
    else if ( document.all )
    {
        elem = eval( "document.all." + id )
        link = eval( "document.all.l_" + id )
    }
    else
        return false;

    if( elem.style.display == "block" )
    {
        elem.style.display = "none"
        link.innerHTML = "Show source"
    }
    else
    {
        elem.style.display = "block"
        link.innerHTML = "Hide source"
    }
}
</script></head>
<body><div id='doc3' class='yui-t2'><div id='hd' class='banner'>
<a style='text-decoration:none;' href='iocp.html'>iocp package reference (V1.0.9)</a>
</div>
<div id='bd'><div id='yui-main'><div class='yui-b'><h1 class='ruff'><a name='::iocp::bt::sdr'></a>::iocp::bt::sdr<span class='tinylink'><a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h1>
<div style='clear:both;'></div>
<p class='ruff'>The <code>iocp::bt::sdr</code> namespace contains commands for parsing Bluetooth <strong>Service Discovery Records</strong> (SDR) as returned by the <a href="iocp_iocp_bt.html#::iocp::bt::device services" title="::iocp::bt::device services" class='ruff_cmd'>::iocp::bt::device services</a> and <a href="iocp_iocp_bt.html#::iocp::bt::device service_references" title="::iocp::bt::device service_references" class='ruff_cmd'>::iocp::bt::device service_references</a> commands. These return a list of binary records which must be first parsed with the <a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr::decode" title="decode" class='ruff_cmd'>decode</a> command. Individual service attributes can then be retrieved from the decoded records using the other commands in the namespace.</p>
<pre class='ruff'>
set dev  [iocp::bt::device_address &quot;APN Phone&quot;]
set recs [iocp::bt::services $dev]
set sdr  [iocp::bt::sdr::decode [lindex $recs 0]]
set service_classes [iocp::bt::sdr::service_classes $sdr]
</pre>
<h2 class='ruff'><a name='::iocp::bt::sdr-Commands'></a>Commands<span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h2>
<div style='clear:both;'></div>
<h4 class='ruffproc'><a name='::iocp::bt::sdr::attribute exists'>attribute exists</a><span class='ns_scope'> [<a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="::iocp::bt::sdr" class='ruff_cmd'>::iocp::bt::sdr</a>]</span><span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Checks if an attribute exists in a service discovery record</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>attribute exists</span> <span class='ruff_arg'>sdr attr_id ?varname?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>sdr</code></td><td class='ruff_defitem'>A decoded service discovery record in the form returned by <a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr::decode" title="decode" class='ruff_cmd'>decode</a>.</td></tr>
<tr><td class='ruff_defitem'><code>attr_id</code></td><td class='ruff_defitem'>Attribute integer id or Bluetooth universal attribute name.</td></tr>
<tr><td class='ruff_defitem'><code>varname</code></td><td class='ruff_defitem'>Optional. If not the empty string, the raw attribute value is stored in a variable of this name in the caller's context. Optional, default <code>&quot;&quot;</code>.</td></tr>
</table>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns 1 if the attribute exists, and 0 otherwise.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_24' href="javascript:toggleSource('24')">Show source</a></p>
<div id='24' class='ruff_dyn_src'><pre>proc ::iocp::bt::sdr::attribute::exists {sdr attr_id {varname {}}} {

    # Checks if an attribute exists in a service discovery record
    # sdr - a decoded service discovery record in the form returned by
    #       [decode].
    # attr_id - attribute integer id or Bluetooth universal attribute name
    # varname - optional. If not the empty string, the raw attribute value is
    #           stored in a variable of this name in the caller's context.
    #
    # Returns 1 if the attribute exists, and 0 otherwise.

    if {[string is integer -strict $attr_id]} {
        set key [expr {$attr_id + 0}]; # Force decimal rep. Faster than format
    } else {
        set key [names::attribute_id $attr_id]; # name -&gt; id
    }

    if {[dict exists $sdr $key]} {
        if {$varname ne &quot;&quot;} {
            upvar 1 $varname value
            set value [dict get $sdr $attr_id]
        }
        return 1
    }

    return 0
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::sdr::attribute get'>attribute get</a><span class='ns_scope'> [<a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="::iocp::bt::sdr" class='ruff_cmd'>::iocp::bt::sdr</a>]</span><span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Get the value of an universal attribute from a service discovery record.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>attribute get</span> <span class='ruff_arg'>sdr attr_id ?varname?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>sdr</code></td><td class='ruff_defitem'>Decoded service discovery record.</td></tr>
<tr><td class='ruff_defitem'><code>attr_id</code></td><td class='ruff_defitem'>Universal attribute name or numeric identifier.</td></tr>
<tr><td class='ruff_defitem'><code>varname</code></td><td class='ruff_defitem'>Optional name of variable in caller's context. Optional, default <code>&quot;&quot;</code>.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>If <code>$varname</code> is not the empty string, it should be the name of a variable in the caller's context.</p>
<ul class='ruff'>
<li>If the attribute is present, the command returns <code>1</code> and stores the attribute value in the variable.</li>
<li>If the attribute is not present, the command returns 0.</li>
</ul>
<p class='ruff'>If <code>$varname</code> is an empty string,</p>
<ul class='ruff'>
<li>If the attribute is present, the command returns its value.</li>
<li>If the attribute is not present, the command raises an error.</li>
</ul>
<p class='ruff'>The attribute value is decoded from its raw format into a attribute type-dependent format.</p>
<p class='ruff'>The <code>$attr_id</code> argument must be one of those defined in the <em>Universal Attributes</em> section in the <a href="https://www.bluetooth.com/specifications/assigned-numbers/service-discovery/" >Bluetooth Assigned Numbers</a> specification. These are listed below. Refer to the Bluetooth specification for their exact semantics.</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>AdditionalProtocolDescriptorList</td><td class='ruff_defitem'>List of protocol stacks. This supplements the <code>ProtocolDescriptorList</code> attribute.</td></tr>
<tr><td class='ruff_defitem'>BluetoothProfileDescriptorList</td><td class='ruff_defitem'>List of Bluetooth profile descriptors to which the service conforms. Each element is a dictionary with keys <code>Uuid</code>, <code>Name</code>, <code>MajorVersion</code> and <code>MinorVersion</code> corresponding to the referenced profile.</td></tr>
<tr><td class='ruff_defitem'>BrowseGroupList</td><td class='ruff_defitem'>List of browse group descriptors representing the browse groups to which the service record belongs. Each descriptor is dictionary with keys <code>Uuid</code> and <code>Name</code> identifying the a browse group.</td></tr>
<tr><td class='ruff_defitem'>ClientExecutableURL</td><td class='ruff_defitem'>URL pointing to the client application that may be used to utilize the service.</td></tr>
<tr><td class='ruff_defitem'>DocumentationURL</td><td class='ruff_defitem'>URL for the service documentation.</td></tr>
<tr><td class='ruff_defitem'>IconURL</td><td class='ruff_defitem'>URL for icon that may be used to represent the service.</td></tr>
<tr><td class='ruff_defitem'>LanguageBaseAttributeIDList</td><td class='ruff_defitem'>Nested dictionary of language-specific attribute offsets (see below).</td></tr>
<tr><td class='ruff_defitem'>ProtocolDescriptorList</td><td class='ruff_defitem'>List of protocol stacks (see below) that may be used to access the service described by the service record.</td></tr>
<tr><td class='ruff_defitem'>ProviderName</td><td class='ruff_defitem'>Name of entity providing the service in the primary language of the service record.</td></tr>
<tr><td class='ruff_defitem'>ServiceAvailability</td><td class='ruff_defitem'>A value in the range 0-255 that indicates relative availability of the service in terms of the number of clients it can accept. Note this is a scaled estimate.</td></tr>
<tr><td class='ruff_defitem'>ServiceClassIDList</td><td class='ruff_defitem'>List with each element being a dictionary corresponding to a service class that the record conforms to. The keys of the dictionary are <code>Name</code> and <code>Uuid</code>.</td></tr>
<tr><td class='ruff_defitem'>ServiceDescription</td><td class='ruff_defitem'>A description of the service in the primary language of the record.</td></tr>
<tr><td class='ruff_defitem'>ServiceID</td><td class='ruff_defitem'>UUID that uniquely identifies a service instance.</td></tr>
<tr><td class='ruff_defitem'>ServiceInfoTimeToLive</td><td class='ruff_defitem'>The number of seconds from the time it was generated that the service record information is expected to be valid.</td></tr>
<tr><td class='ruff_defitem'>ServiceName</td><td class='ruff_defitem'>The human-readable name of the service in the primary language of the record.</td></tr>
<tr><td class='ruff_defitem'>ServiceRecordHandle</td><td class='ruff_defitem'>A numeric value that uniquely identifies a service record within a SDP server.</td></tr>
<tr><td class='ruff_defitem'>ServiceRecordState</td><td class='ruff_defitem'>Numeric value that is changed any time the service record is modified by the SDP server.</td></tr>
</table>
<p class='ruff'>In the case of ProtocolDescriptorList and AdditionalProtocolDescriptorList, the attribute value is in the form of a list each element of which describes a protocol stack that may be used to access the service. Each such element is itself a list whose elements correspond to layers in that protocol stack starting with the lowest layer first. Each layer is described as a dictionary with the following keys:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>Uuid</td><td class='ruff_defitem'>The UUID of the protocol for the layer.</td></tr>
<tr><td class='ruff_defitem'>Name</td><td class='ruff_defitem'>The name of the protocol.</td></tr>
<tr><td class='ruff_defitem'>Params</td><td class='ruff_defitem'>The protocol parameters. This is a list of raw data elements of the form <code>{type value}</code> the interpretation of which is protocol dependent.</td></tr>
</table>
<p class='ruff'>In the case of LanguageBaseAttributeIDList, the attribute value is a dictionary indexed by language identifiers as defined in ISO639, e.g. <code>en</code>, <code>fr</code> etc. The corresponding value is itself a dictionary with keys <code>BaseOffset</code> and <code>Encoding</code>. See the Bluetooth specification for the former. The latter is either a Tcl encoding name or in case the encoding is not supported by Tcl, an integer value that identifies an encoding as per the Bluetooth specification.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a boolean or the decoded attribute value.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_25' href="javascript:toggleSource('25')">Show source</a></p>
<div id='25' class='ruff_dyn_src'><pre>proc ::iocp::bt::sdr::attribute::get {sdr attr_id {varname {}}} {

    # Get the value of an universal attribute from a service
    # discovery record.
    #  sdr     - Decoded service discovery record.
    #  attr_id - Universal attribute name or numeric identifier.
    #  varname - Optional name of variable in caller's context.
    #
    # If $varname is not the empty string, it should be the name of
    # a variable in the caller's context.
    #  - If the attribute is present, the command returns `1` and
    #    stores the attribute value in the variable.
    #  - If the attribute is not present, the command returns 0.
    #
    # If $varname is an empty string,
    #  - If the attribute is present, the command returns its value.
    #  - If the attribute is not present, the command raises an error.
    #
    # The attribute value is decoded from its raw format into a
    # attribute type-dependent format.
    #
    # The $attr_id argument must be one of those defined in
    # the *Universal Attributes* section in the
    # [Bluetooth Assigned Numbers](https://www.bluetooth.com/specifications/assigned-numbers/service-discovery/)
    # specification. These are listed below. Refer to the Bluetooth
    # specification for their exact semantics.
    #
    # AdditionalProtocolDescriptorList - List of protocol stacks. This
    #    supplements the `ProtocolDescriptorList` attribute.
    # BluetoothProfileDescriptorList - List of Bluetooth profile descriptors
    #    to which the service conforms. Each element is a dictionary
    #    with keys `Uuid`, `Name`, `MajorVersion` and `MinorVersion`
    #    corresponding to the referenced profile.
    # BrowseGroupList - List of browse group descriptors representing
    #    the browse groups to which the service record belongs. Each
    #    descriptor is dictionary with keys `Uuid` and `Name` identifying
    #    the a browse group.
    # ClientExecutableURL - URL pointing to the client application that
    #    may be used to utilize the service.
    # DocumentationURL - URL for the service documentation.
    # IconURL - URL for icon that may be used to represent the service.
    # LanguageBaseAttributeIDList - Nested dictionary of language-specific
    #    attribute offsets (see below).
    # ProtocolDescriptorList - List of protocol stacks (see below) that may
    #    be used to access the service described by the service record.
    # ProviderName - Name of entity providing the service in the primary
    #    language of the service record.
    # ServiceAvailability - A value in the range 0-255 that indicates
    #    relative availability of the service in terms of the number of
    #    clients it can accept. Note this is a scaled estimate.
    # ServiceClassIDList - List with each element being a dictionary
    #    corresponding to a service class that the record conforms to.
    #    The keys of the dictionary are `Name` and `Uuid`.
    # ServiceDescription - A description of the service in the primary
    #    language of the record.
    # ServiceID - UUID that uniquely identifies a service instance.
    # ServiceInfoTimeToLive - The number of seconds from the time it was
    #    generated that the service record information is expected to be valid.
    # ServiceName - The human-readable name of the service in the primary
    #    language of the record.
    # ServiceRecordHandle - A numeric value that uniquely identifies a service
    #    record within a SDP server.
    # ServiceRecordState - Numeric value that is changed any time the service
    #    record is modified by the SDP server.
    #
    # In the case of ProtocolDescriptorList and AdditionalProtocolDescriptorList,
    # the attribute value is in the form of a list each element of
    # which describes a protocol stack that may be used to access the
    # service. Each such element is itself a list whose elements correspond
    # to layers in that protocol stack starting with the lowest layer first.
    # Each layer is described as a dictionary with the following keys:
    #  Uuid - the UUID of the protocol for the layer
    #  Name - the name of the protocol
    #  Params - the protocol parameters. This is a list of raw data elements
    #           of the form `{type value}` the interpretation of which is
    #           protocol dependent.
    #
    # In the case of LanguageBaseAttributeIDList, the attribute value is
    # a dictionary indexed by language
    # identifiers as defined in ISO639, e.g. `en`, `fr` etc.
    # The corresponding value is itself a dictionary with keys `BaseOffset`
    # and `Encoding`. See the Bluetooth specification for the former.
    # The latter is either a Tcl encoding name or in case the encoding
    # is not supported by Tcl, an integer value that identifies an encoding
    # as per the Bluetooth specification.
    #
    # Returns a boolean or the decoded attribute value.

    set attr_name [names::attribute_name $attr_id]
    set attr_id   [names::attribute_id $attr_id]
    switch -exact -- $attr_name {
        BrowseGroupList -
        ServiceClassIDList {
            tailcall Uuids $sdr $attr_id $varname
        }
        BluetoothProfileDescriptorList -
        ProtocolDescriptorList -
        AdditionalProtocolDescriptorList -
        LanguageBaseAttributeIDList {
            tailcall $attr_name $sdr $varname
        }
        DocumentationURL -
        ClientExecutableURL -
        IconURL -
        ServiceAvailability -
        ServiceInfoTimeToLive -
        ServiceID -
        ServiceRecordState -
        ServiceRecordHandle {
            tailcall AttributeValue $sdr $attr_id $varname
        }
        ServiceName -
        ServiceDescription -
        ProviderName {
            # Special case because they need a language argument
            tailcall text $sdr $attr_name primary $varname
        }
        default {
            if {[llength [info commands [namespace current]::universal::$attr_name]]} {
                tailcall [namespace current]::universal::$attr_name $sdr $varname
            }
        }
    }
    error &quot;Unknown universal attribute \&quot;$attr_id\&quot;.&quot;
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::sdr::attribute raw'>attribute raw</a><span class='ns_scope'> [<a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="::iocp::bt::sdr" class='ruff_cmd'>::iocp::bt::sdr</a>]</span><span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Get an attribute value from an service discovery record.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>attribute raw</span> <span class='ruff_arg'>sdr attr_id</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>sdr</code></td><td class='ruff_defitem'>A decoded service discovery record in the form returned by sdr_decode.</td></tr>
<tr><td class='ruff_defitem'><code>attr_id</code></td><td class='ruff_defitem'>Attribute integer id.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>The command will raise an error if the attribute does not exist in the sdr.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns the attribute value as a pair consisting of the type and the raw data element value.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_26' href="javascript:toggleSource('26')">Show source</a></p>
<div id='26' class='ruff_dyn_src'><pre>proc ::iocp::bt::sdr::attribute::raw {sdr attr_id} {

    # Get an attribute value from an service discovery record.
    # sdr - a decoded service discovery record in the form returned by
    #       sdr_decode.
    # attr_id   - attribute integer id
    #
    # The command will raise an error if the attribute does not exist
    # in the sdr.
    #
    # Returns the attribute value as a pair consisting of the type and
    # the raw data element value.

    if {[exists $sdr $attr_id value]} {
        return $value
    } else {
        error &quot;Attribute with id \&quot;$attr_id\&quot; not found.&quot;
    }
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::sdr::attribute text'>attribute text</a><span class='ns_scope'> [<a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="::iocp::bt::sdr" class='ruff_cmd'>::iocp::bt::sdr</a>]</span><span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Get the value of an text attribute in the specified language from a service discovery record.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>attribute text</span> <span class='ruff_arg'>sdr attr_id lang ?varname?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>sdr</code></td><td class='ruff_defitem'>Decoded service discovery record.</td></tr>
<tr><td class='ruff_defitem'><code>attr_id</code></td><td class='ruff_defitem'>Universal attribute name or numeric identifier.</td></tr>
<tr><td class='ruff_defitem'><code>lang</code></td><td class='ruff_defitem'>Language identifier as specified in iso639, e.g. <code>en</code> for english, <code>fr</code> for french etc. or the keyword <code>primary</code>.</td></tr>
<tr><td class='ruff_defitem'><code>varname</code></td><td class='ruff_defitem'>Optional name of variable in caller's context. Optional, default <code>&quot;&quot;</code>.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>If <code>$varname</code> is not the empty string, it should be the name of a variable in the caller's context.</p>
<ul class='ruff'>
<li>If the attribute is present, the command returns <code>1</code> and stores the attribute value in the variable.</li>
<li>If the attribute is not present, the command returns 0.</li>
</ul>
<p class='ruff'>If <code>$varname</code> is an empty string,</p>
<ul class='ruff'>
<li>If the attribute is present, the command returns its value.</li>
<li>If the attribute is not present, the command raises an error.</li>
</ul>
<p class='ruff'>If the record does not contain a value for the specified language, the value for the primary language will be retrieved.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a boolean or the attribute text value.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_27' href="javascript:toggleSource('27')">Show source</a></p>
<div id='27' class='ruff_dyn_src'><pre>proc ::iocp::bt::sdr::attribute::text {sdr attr_id lang {varname {}}} {

    # Get the value of an text attribute in the specified language
    # from a service discovery record.
    #  sdr     - Decoded service discovery record.
    #  attr_id - Universal attribute name or numeric identifier.
    #  lang - language identifier as specified in iso639, e.g. `en` for
    #         english, `fr` for french etc. or the keyword `primary`.
    #  varname - Optional name of variable in caller's context.
    #
    # If $varname is not the empty string, it should be the name of
    # a variable in the caller's context.
    #  - If the attribute is present, the command returns `1` and
    #    stores the attribute value in the variable.
    #  - If the attribute is not present, the command returns 0.
    #
    # If $varname is an empty string,
    #  - If the attribute is present, the command returns its value.
    #  - If the attribute is not present, the command raises an error.
    #
    # If the record does not contain a value for the specified language,
    # the value for the primary language will be retrieved.
    #
    # Returns a boolean or the attribute text value.
    #
    set lang_offset [names::attribute_id $attr_id]
    if {$lang_offset &lt; 256 || $lang_offset &gt;= 512} {
        error &quot;Invalid text attribute id \&quot;$attr_id\&quot;.&quot;
    }
    incr lang_offset -256
    tailcall TextAttribute $sdr $lang_offset $lang $varname
}
# NOTE: showing source of procedure implementing ensemble subcommand.</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::sdr::attributes'>attributes</a><span class='ns_scope'> [<a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="::iocp::bt::sdr" class='ruff_cmd'>::iocp::bt::sdr</a>]</span><span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Get the list of attributes in a service discovery record</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>attributes</span> <span class='ruff_arg'>sdr</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>sdr</code></td><td class='ruff_defitem'>A decoded service discovery record in the form returned by <a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr::decode" title="decode" class='ruff_cmd'>decode</a>.</td></tr>
</table>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a list of numeric attribute ids.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_28' href="javascript:toggleSource('28')">Show source</a></p>
<div id='28' class='ruff_dyn_src'><pre>proc ::iocp::bt::sdr::attributes {sdr} {

    # Get the list of attributes in a service discovery record
    # sdr - a decoded service discovery record in the form returned by
    #       [decode].
    # Returns a list of numeric attribute ids.
    return [lmap {attr val} $sdr {set attr}]
}</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::sdr::decode'>decode</a><span class='ns_scope'> [<a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="::iocp::bt::sdr" class='ruff_cmd'>::iocp::bt::sdr</a>]</span><span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Decodes a binary service discovery record</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>decode</span> <span class='ruff_arg'>binsdr</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>binsdr</code></td><td class='ruff_defitem'>A raw Bluetooth service discovery record in binary form.</td></tr>
</table>
<h5 class='ruff'>Description</h5><p class='ruff'>The returned value should be treated as opaque. The attributes stored in the record should be accessed with the commands in the <code>sdr</code> namespace.</p>
<h5 class='ruff'>Return value</h5><p class='ruff'>Returns a container of attributes stored in the record.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_29' href="javascript:toggleSource('29')">Show source</a></p>
<div id='29' class='ruff_dyn_src'><pre>proc ::iocp::bt::sdr::decode {binsdr} {

    # Decodes a binary service discovery record
    # binsdr - a raw Bluetooth service discovery record in binary
    #       form.
    #
    # The returned value should be treated as opaque. The attributes
    # stored in the record should be accessed with the commands in
    # the `sdr` namespace.
    #
    # Returns a container of attributes stored in the record.

    # A SDR record is a single data element which is a sequence
    # containing nested data elements.
    # {{sequence {nested data elements}}}
    set rec [lindex [DecodeElements $binsdr] 0 1]

    # $rec contains alternating attribute value pairs. The result
    # is built as a list as its faster to do that and shimmer
    # to a dict on access than to build a dictionary to begin with.
    set sdr {}
    foreach {attr val} $rec {
        lappend sdr [lindex $attr 1] $val
    }
    return $sdr
}</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::sdr::print'>print</a><span class='ns_scope'> [<a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="::iocp::bt::sdr" class='ruff_cmd'>::iocp::bt::sdr</a>]</span><span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Prints a SDP record to a more human readable form.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>print</span> <span class='ruff_arg'>rec ?attrfilter?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>rec</code></td><td class='ruff_defitem'>A binary SDP record in the form returned by <a href="iocp_iocp_bt.html#::iocp::bt::device services" title="::iocp::bt::device services" class='ruff_cmd'>::iocp::bt::device services</a> or <a href="iocp_iocp_bt.html#::iocp::bt::device service_references" title="::iocp::bt::device service_references" class='ruff_cmd'>::iocp::bt::device service_references</a>.</td></tr>
<tr><td class='ruff_defitem'><code>attrfilter</code></td><td class='ruff_defitem'>If specified, only attribute names matching the filter using <code>string match</code> are printed. Optional, default <code>*</code>.</td></tr>
</table>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_30' href="javascript:toggleSource('30')">Show source</a></p>
<div id='30' class='ruff_dyn_src'><pre>proc ::iocp::bt::sdr::print {rec {attrfilter *}} {

    # Prints a SDP record to a more human readable form.
    # rec - a binary SDP record in the form returned by [::iocp::bt::device services] or
    #       [::iocp::bt::device service_references].
    # attrfilter - If specified, only attribute names matching the filter
    #       using `string match` are printed.
    #

    # Alternating attribute value pairs
    set rec [decode $rec]
    foreach attr [attributes $rec] {
        set attrname [names::attribute_name $attr]
        if {[string is integer -strict $attrname]} {
            # For easier matching with Bluetooth specs
            set attrname [format 0x%x $attrname]
        }
        if {![string match -nocase $attrfilter $attrname]} {
            continue
        }
        switch -exact -- $attrname {
            ServiceID -
            ServiceRecordState -
            ServiceInfoTimeToLive -
            ServiceAvailability -
            DocumentationURL -
            ClientExecutableURL -
            IconURL -
            ServiceName -
            ServiceDescription -
            ProviderName -
            ServiceRecordHandle {
                puts &quot;$attrname: [attribute get $rec $attrname]&quot;
            }
            ServiceClassIDList {
                puts &quot;$attrname: sequence&quot;
                foreach elem [attribute get $rec $attrname] {
                    dict with elem {
                        # We use this for printing service-specific attributes
                        lappend service_class_uuids $Uuid
                        if {$Name eq $Uuid} {
                            puts &quot;    $Uuid&quot;
                        } else {
                            puts &quot;    $Uuid $Name&quot;
                        }
                    }
                }
            }
            ProtocolDescriptorList {
                puts &quot;$attrname:&quot;
                foreach protocol [attribute get $rec $attrname] {
                    puts &quot;    ProtocolStack:&quot;
                    foreach layer $protocol {
                        set name [dict get $layer ProtocolName]
                        set uuid [dict get $layer Protocol]
                        set params [lmap param [dict get $layer ProtocolParams] {
                            PrintableElement $param
                        }]
                        if {$name eq &quot;&quot;} {
                            puts &quot;        $uuid ([join $params {, }])&quot;
                        } else {
                            puts &quot;        $uuid $name ([join $params {, }])&quot;
                        }
                    }
                }
            }
            AdditionalProtocolDescriptorList {
                # Like ProtocolDescriptorList but an additional level
                # of nesting.
                puts &quot;$attrname:&quot;
                foreach additional_protocol [attribute get $rec $attrname] {
                    foreach protocol $additional_protocol {
                        puts &quot;    ProtocolStack:&quot;
                        foreach layer $protocol {
                            set name [dict get $layer ProtocolName]
                            set uuid [dict get $layer Protocol]
                            set params [lmap param [dict get $layer ProtocolParams] {
                                PrintableElement $param
                            }]
                            if {$name eq &quot;&quot;} {
                                puts &quot;        $uuid ([join $params {, }])&quot;
                            } else {
                                puts &quot;        $uuid $name ([join $params {, }])&quot;
                            }
                        }
                    }
                }
            }
            BrowseGroupList {
                puts &quot;$attrname: sequence&quot;
                foreach elem [attribute get $rec $attrname] {
                    dict with elem {
                        if {$Name eq $Uuid} {
                            puts &quot;    $Uuid&quot;
                        } else {
                            puts &quot;    $Uuid $Name&quot;
                        }
                    }
                }
            }
            LanguageBaseAttributeIDList {
                puts &quot;$attrname: sequence&quot;
                dict for {lang val} [attribute get $rec $attrname] {
                    puts &quot;    $lang: [dict get $val Encoding], [dict get $val BaseOffset]&quot;
                }
            }
            BluetoothProfileDescriptorList {
                puts &quot;$attrname: sequence&quot;
                foreach profile [attribute get $rec $attrname] {
                    # Sequence of profiles. Each profile is a sequence of
                    # profile uuid and version.
                    # puts profile:$profile
                    dict with profile {
                        if {$Uuid eq $Name} {
                            puts &quot;    $Uuid v$MajorVersion.$MinorVersion&quot;
                        } else {
                            puts &quot;    $Uuid $Name v$MajorVersion.$MinorVersion&quot;
                        }
                    }
                }
            }
            default {
                if {$attr &gt;= 0x100 &amp;&amp; $attr &lt;= 0x1ff} {
                    # TBD - special handling for 0x100-0x1ff attributes by
                    # looking up languages table
                    puts &quot;$attrname: [PrintableElement [attribute raw $rec $attr]]&quot;
                } else {
                    lassign [PrintableServiceSpecificAttribute  $service_class_uuids $rec $attr] attrname attrval
                    puts &quot;$attrname: $attrval&quot;
                }
            }
        }
    }
}</pre></div>
</div><h4 class='ruffproc'><a name='::iocp::bt::sdr::printn'>printn</a><span class='ns_scope'> [<a href="iocp_iocp_bt_sdr.html#::iocp::bt::sdr" title="::iocp::bt::sdr" class='ruff_cmd'>::iocp::bt::sdr</a>]</span><span class='tinylink'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr'>sdr</a>, <a href='#top'>Top</a>, <a href='iocp.html'>Main</a>, <a href='iocp_docindex.html#'>Index</a></span></h4>
<div style='clear:both;'></div>
<p class='ruff'>Prints a SDP record to a more human readable form.</p>
<div class='ruff_synopsis'><span class='ruff_cmd'>printn</span> <span class='ruff_arg'>recs ?attrfilter?</span></div>
<h5 class='ruff'>Parameters</h5><table class='ruff_deflist'>
<tr><td class='ruff_defitem'><code>recs</code></td><td class='ruff_defitem'>A list of binary SDP records in the form returned by <a href="iocp_iocp_bt.html#::iocp::bt::device services" title="::iocp::bt::device services" class='ruff_cmd'>::iocp::bt::device services</a> or <a href="iocp_iocp_bt.html#::iocp::bt::device service_references" title="::iocp::bt::device service_references" class='ruff_cmd'>::iocp::bt::device service_references</a>.</td></tr>
<tr><td class='ruff_defitem'><code>attrfilter</code></td><td class='ruff_defitem'>If specified, only attribute names matching the filter using <code>string match</code> are printed. Optional, default <code>*</code>.</td></tr>
</table>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_31' href="javascript:toggleSource('31')">Show source</a></p>
<div id='31' class='ruff_dyn_src'><pre>proc ::iocp::bt::sdr::printn {recs {attrfilter *}} {

    # Prints a SDP record to a more human readable form.
    # recs - a list of binary SDP records in the form returned by
    #        [::iocp::bt::device services] or [::iocp::bt::device service_references].
    # attrfilter - If specified, only attribute names matching the filter
    #       using `string match` are printed.
    #
    set sep &quot;&quot;
    foreach rec $recs {
        puts $sep
        set sep &quot;--------------------------------------------&quot;
        print $rec $attrfilter
    }
}</pre></div>
</div></div></div><div class='yui-b navbox' style='position: fixed;'><h1><a style='padding-top:2px;' href='iocp.html'>Start page</a></h1>
<h1><a href='iocp_docindex.html' accesskey='i'>Index</a></h1>
<hr>
<h1><a href='iocp_iocp_bt.html'>iocp::bt</a></h1>
<h1><a href='iocp_iocp_bt_names.html'>iocp::bt::names</a></h1>
<h1><a style='color: #006666;background-color: white; margin-left:-4px; padding-left:3px;padding-right:2px;' href='iocp_iocp_bt_sdr.html'>iocp::bt::sdr</a></h1>
<h1><a href='iocp_iocp_inet.html'>iocp::inet</a></h1>
<hr><h1><a href='#::iocp::bt::sdr'>iocp::bt::sdr</a></h1><h2><a href='#::iocp::bt::sdr-Commands'>Commands</a></h2><h4 class='tooltip'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr::attribute exists'>attribute exists</a><span class='tooltiptext'>Checks if an attribute exists in a service discovery record
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr::attribute get'>attribute get</a><span class='tooltiptext'>Get the value of an universal attribute from a service discovery record.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr::attribute raw'>attribute raw</a><span class='tooltiptext'>Get an attribute value from an service discovery record.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr::attribute text'>attribute text</a><span class='tooltiptext'>Get the value of an text attribute in the specified language from a service discovery record.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr::attributes'>attributes</a><span class='tooltiptext'>Get the list of attributes in a service discovery record
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr::decode'>decode</a><span class='tooltiptext'>Decodes a binary service discovery record
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr::print'>print</a><span class='tooltiptext'>Prints a SDP record to a more human readable form.
</span></h4><h4 class='tooltip'><a href='iocp_iocp_bt_sdr.html#::iocp::bt::sdr::printn'>printn</a><span class='tooltiptext'>Prints a SDP record to a more human readable form.
</span></h4></div></div><div id='ft'><div style='float: right;'>Document generated by <a href='https://ruff.magicsplat.com'>Ruff!</a></div></div>
</div></body></html>
